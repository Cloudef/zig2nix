const std = @import("std");
const cli = @import("cli.zig");
const zon2lock = @import("zon2lock.zig");

fn writeInternal(arena: std.mem.Allocator, lock: zon2lock.Lock, out: anytype) !void {
    var pipe = try cli.pipe(arena, null, &.{ "nixfmt", "-v" });
    defer pipe.deinit();
    const writer = pipe.writer();

    try writer.writeAll(
        \\# generated by zon2nix (https://github.com/Cloudef/zig2nix)
        \\
        \\{
        \\  lib,
        \\  linkFarm,
        \\  fetchurl,
        \\  fetchgit,
        \\  runCommandLocal,
        \\  zig,
        \\  name ? "zig-packages",
        \\}:
        \\
        \\with builtins;
        \\with lib;
        \\
        \\let
        \\  unpackZigArtifact = { name, artifact }:
        \\    runCommandLocal name { nativeBuildInputs = [ zig ]; }
        \\    ''
        \\    hash="$(zig fetch --global-cache-dir "$TMPDIR" ${artifact})"
        \\    mv "$TMPDIR/p/$hash" "$out"
        \\    chmod 755 "$out"
        \\    '';
        \\
        \\  fetchZig = { name, url, hash }: let
        \\    artifact = fetchurl { inherit url hash; };
        \\  in unpackZigArtifact { inherit name artifact; };
        \\
        \\  fetchGitZig = { name, url, hash, rev ? throw "rev is required, remove and regenerate the zon2json-lock file" }: let
        \\    parts = splitString "#" url;
        \\    url_base = elemAt parts 0;
        \\    url_without_query = elemAt (splitString "?" url_base) 0;
        \\  in fetchgit {
        \\    inherit name rev hash;
        \\    url = url_without_query;
        \\    deepClone = false;
        \\  };
        \\
        \\  fetchZigArtifact = { name, url, hash, ... } @ args: let
        \\    parts = splitString "://" url;
        \\    proto = elemAt parts 0;
        \\    path = elemAt parts 1;
        \\    fetcher = {
        \\      "git+http" = fetchGitZig (args // {
        \\        url = "http://${path}";
        \\      });
        \\      "git+https" = fetchGitZig (args // {
        \\        url = "https://${path}";
        \\      });
        \\      http = fetchZig {
        \\        inherit name hash;
        \\        url = "http://${path}";
        \\      };
        \\      https = fetchZig {
        \\        inherit name hash;
        \\        url = "https://${path}";
        \\      };
        \\    };
        \\  in fetcher.${proto};
        \\in linkFarm name [
        \\
    );

    var iter = lock.map.iterator();
    while (iter.next()) |kv| {
        const zhash = kv.key_ptr.*;
        const dep = kv.value_ptr;
        try writer.writeAll("{\n");
        try writer.print("name = \"{s}\";\n", .{zhash});
        try writer.writeAll("path = fetchZigArtifact {\n");
        try writer.print("name = \"{s}\";\n", .{dep.name});
        try writer.print("url = \"{s}\";\n", .{dep.url});
        try writer.print("hash = \"{s}\";\n", .{dep.hash});
        if (dep.rev) |rev| try writer.print("rev = \"{s}\";\n", .{rev});
        try writer.writeAll("};\n");
        try writer.writeAll("}\n");
    }

    try writer.writeAll("]");
    pipe.close();
    pipe.reader().streamUntilDelimiter(out, 0, null) catch |err| switch (err) {
        error.EndOfStream => {},
        else => |e| return e,
    };

    return switch (try pipe.finish()) {
        .Exited => |status| switch (status) {
            0 => {},
            else => error.NixFmtFailed,
        },
        else => error.NixFmtFailed,
    };
}

pub fn write(allocator: std.mem.Allocator, cwd: std.fs.Dir, path: []const u8, writer: anytype) !void {
    var arena_state: std.heap.ArenaAllocator = .init(allocator);
    defer arena_state.deinit();
    const arena = arena_state.allocator();
    var lock = (try zon2lock.parsePath(arena, cwd, path)) orelse return;
    defer lock.deinit();
    try writeInternal(arena, lock, writer);
}
